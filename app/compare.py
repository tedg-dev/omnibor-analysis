#!/usr/bin/env python3
"""
OmniBOR Analysis — SBOM Comparison script.

Compares SPDX SBOMs generated by OmniBOR (build interception)
against SBOMs from proprietary binary scanning tools.

Usage:
    python3 compare.py --repo curl
    python3 compare.py --repo curl --omnibor-file path --binary-file path
"""

import argparse
import json
import os
import sys
import yaml
from datetime import datetime
from pathlib import Path


def load_config():
    config_path = Path(__file__).parent / "config.yaml"
    with open(config_path, "r") as f:
        return yaml.safe_load(f)


def timestamp():
    return datetime.now().strftime("%Y-%m-%d_%H%M")


def load_spdx(filepath):
    """Load an SPDX JSON file and extract package list."""
    with open(filepath, "r") as f:
        data = json.load(f)
    packages = data.get("packages", [])
    return data, packages


def extract_package_names(packages):
    """Extract normalized package names from SPDX packages."""
    names = set()
    for pkg in packages:
        name = pkg.get("name", "").lower().strip()
        if name:
            names.add(name)
    return names


def extract_package_map(packages):
    """Build a dict of name -> package details."""
    pkg_map = {}
    for pkg in packages:
        name = pkg.get("name", "").lower().strip()
        if name:
            pkg_map[name] = {
                "name": pkg.get("name", ""),
                "version": pkg.get("versionInfo", "UNKNOWN"),
                "supplier": pkg.get("supplier", "UNKNOWN"),
                "spdxId": pkg.get("SPDXID", ""),
            }
    return pkg_map


def compare_sboms(omnibor_pkgs, binary_pkgs):
    """Compare two sets of packages and return analysis."""
    omnibor_names = extract_package_names(omnibor_pkgs)
    binary_names = extract_package_names(binary_pkgs)

    omnibor_map = extract_package_map(omnibor_pkgs)
    binary_map = extract_package_map(binary_pkgs)

    common = omnibor_names & binary_names
    omnibor_only = omnibor_names - binary_names
    binary_only = binary_names - omnibor_names

    # Check version agreement on common packages
    version_match = []
    version_mismatch = []
    for name in sorted(common):
        ov = omnibor_map[name]["version"]
        bv = binary_map[name]["version"]
        if ov == bv:
            version_match.append((name, ov))
        else:
            version_mismatch.append((name, ov, bv))

    return {
        "omnibor_total": len(omnibor_names),
        "binary_total": len(binary_names),
        "common": sorted(common),
        "omnibor_only": sorted(omnibor_only),
        "binary_only": sorted(binary_only),
        "version_match": version_match,
        "version_mismatch": version_mismatch,
        "omnibor_map": omnibor_map,
        "binary_map": binary_map,
    }


def generate_report(repo_name, result, omnibor_file, binary_file):
    """Generate a markdown comparison report."""
    now = datetime.now().isoformat()
    total_union = len(
        set(result["common"])
        | set(result["omnibor_only"])
        | set(result["binary_only"])
    )
    overlap_pct = (
        (len(result["common"]) / total_union * 100)
        if total_union > 0 else 0
    )

    report = f"""# SBOM Comparison Report — {repo_name}

**Date:** {now}
**OmniBOR SPDX:** `{omnibor_file}`
**Binary Scan SPDX:** `{binary_file}`

## Summary

| Metric | Value |
|--------|-------|
| OmniBOR packages | {result['omnibor_total']} |
| Binary scan packages | {result['binary_total']} |
| Common (both detected) | {len(result['common'])} |
| OmniBOR only | {len(result['omnibor_only'])} |
| Binary scan only | {len(result['binary_only'])} |
| Overlap | {overlap_pct:.1f}% |
| Version agreement | {len(result['version_match'])} |
| Version mismatch | {len(result['version_mismatch'])} |

## Common Packages (detected by both)

| Package | OmniBOR Version | Binary Scan Version | Match |
|---------|----------------|--------------------:|-------|
"""
    for name in result["common"]:
        ov = result["omnibor_map"][name]["version"]
        bv = result["binary_map"][name]["version"]
        match = "YES" if ov == bv else "**NO**"
        report += f"| {name} | {ov} | {bv} | {match} |\n"

    report += """
## OmniBOR Only (not detected by binary scanner)

These components were identified during build interception but not
found by the binary scanner. Possible reasons:
- Source-only headers or build-time dependencies
- Components compiled into the binary without distinct signatures
- Intermediate build artifacts

"""
    for name in result["omnibor_only"]:
        pkg = result["omnibor_map"][name]
        report += f"- **{pkg['name']}** ({pkg['version']})\n"

    report += """
## Binary Scan Only (not detected by OmniBOR)

These components were identified by binary signature matching but not
tracked by build interception. Possible reasons:
- Pre-compiled commercial SDKs or vendor binaries
- Statically linked libraries from system packages
- Components not compiled from source in this build

"""
    for name in result["binary_only"]:
        pkg = result["binary_map"][name]
        report += f"- **{pkg['name']}** ({pkg['version']})\n"

    if result["version_mismatch"]:
        report += """
## Version Mismatches

| Package | OmniBOR | Binary Scan |
|---------|---------|-------------|
"""
        for name, ov, bv in result["version_mismatch"]:
            report += f"| {name} | {ov} | {bv} |\n"

    report += f"""
## Analysis Notes

- **OmniBOR strengths:** Tracks every source file through compilation;
  captures undeclared and transitive build dependencies
- **Binary scan strengths:** Detects pre-compiled commercial components
  and statically linked code not visible to build interception
- **Combined coverage** provides the most complete SBOM

---
*Generated by omnibor-analysis compare.py on {now}*
"""
    return report


def find_latest_file(directory, pattern):
    """Find the most recently modified file matching a pattern."""
    d = Path(directory)
    if not d.exists():
        return None
    files = sorted(d.glob(pattern), key=os.path.getmtime, reverse=True)
    return str(files[0]) if files else None


def main():
    parser = argparse.ArgumentParser(
        description="Compare OmniBOR vs binary scan SBOMs"
    )
    parser.add_argument("--repo", required=True,
                        help="Repository name from config.yaml")
    parser.add_argument("--omnibor-file",
                        help="Path to OmniBOR SPDX JSON file")
    parser.add_argument("--binary-file",
                        help="Path to binary scan SPDX JSON file")
    args = parser.parse_args()

    config = load_config()
    paths_cfg = config["paths"]

    # Find SPDX files
    omnibor_file = args.omnibor_file or find_latest_file(
        Path(paths_cfg["output_dir"]) / "spdx" / args.repo,
        f"{args.repo}_omnibor_*.spdx.json"
    )
    binary_file = args.binary_file or find_latest_file(
        Path(paths_cfg["output_dir"]) / "binary-scan" / args.repo,
        "*.spdx.json"
    )

    if not omnibor_file:
        print("[ERROR] No OmniBOR SPDX file found. "
              "Run analyze.py first or specify --omnibor-file")
        sys.exit(1)

    if not binary_file:
        print("[ERROR] No binary scan SPDX file found. "
              "Place it in output/binary-scan/<repo>/ "
              "or specify --binary-file")
        sys.exit(1)

    print(f"OmniBOR SPDX: {omnibor_file}")
    print(f"Binary scan SPDX: {binary_file}")

    # Load and compare
    _, omnibor_pkgs = load_spdx(omnibor_file)
    _, binary_pkgs = load_spdx(binary_file)

    result = compare_sboms(omnibor_pkgs, binary_pkgs)

    # Generate report
    report = generate_report(
        args.repo, result, omnibor_file, binary_file
    )

    # Write to docs
    docs_dir = Path(paths_cfg["docs_dir"]) / args.repo
    docs_dir.mkdir(parents=True, exist_ok=True)
    ts = timestamp()
    report_path = docs_dir / f"{ts}_comparison.md"
    with open(report_path, "w") as f:
        f.write(report)

    print(f"\n[OK] Comparison report: {report_path}")
    print(f"     Common: {len(result['common'])}")
    print(f"     OmniBOR only: {len(result['omnibor_only'])}")
    print(f"     Binary only: {len(result['binary_only'])}")
    print(f"     Version mismatches: "
          f"{len(result['version_mismatch'])}")


if __name__ == "__main__":
    main()
