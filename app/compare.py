#!/usr/bin/env python3
"""
OmniBOR Analysis — SBOM Comparison script.

Compares SPDX SBOMs generated by OmniBOR (build interception)
against SBOMs from proprietary binary scanning tools.

Usage:

    python3 compare.py --repo curl
    python3 compare.py --repo curl --omnibor-file path --binary-file path

Classes:

    - SpdxLoader: loads and parses SPDX JSON files
    - PackageExtractor: extracts and normalizes package data
    - SbomComparator: compares two SPDX package sets
    - ReportGenerator: generates markdown comparison reports
    - ComparisonPipeline: facade orchestrating the full workflow
"""

import argparse
import json
import os
import sys
import yaml
from datetime import datetime
from pathlib import Path


# ============================================================
# Utilities
# ============================================================

def load_config(config_path=None):
    """Load config.yaml from the given path or script directory."""
    if config_path is None:
        config_path = (
            Path(__file__).parent / "config.yaml"
        )
    with open(
        config_path, "r", encoding="utf-8"
    ) as f:
        return yaml.safe_load(f)


def timestamp():
    """Return current timestamp in configured format."""
    return datetime.now().strftime("%Y-%m-%d_%H%M")


# ============================================================
# SPDX file loading
# ============================================================

class SpdxLoader:
    """Loads and parses SPDX JSON files."""

    @staticmethod
    def load(filepath):
        """Load an SPDX JSON file and extract package list.

        Returns (full_data, packages) tuple.
        """
        with open(
            filepath, "r", encoding="utf-8"
        ) as f:
            data = json.load(f)
        packages = data.get("packages", [])
        return data, packages

    @staticmethod
    def find_latest(directory, pattern):
        """Find the most recently modified file matching a pattern."""
        d = Path(directory)
        if not d.exists():
            return None
        files = sorted(
            d.glob(pattern),
            key=os.path.getmtime,
            reverse=True,
        )
        return str(files[0]) if files else None


# ============================================================
# Package extraction
# ============================================================

class PackageExtractor:
    """Extracts and normalizes package data from SPDX packages."""

    @staticmethod
    def extract_names(packages):
        """Extract normalized package names."""
        names = set()
        for pkg in packages:
            name = (
                pkg.get("name", "").lower().strip()
            )
            if name:
                names.add(name)
        return names

    @staticmethod
    def extract_map(packages):
        """Build a dict of name -> package details."""
        pkg_map = {}
        for pkg in packages:
            name = (
                pkg.get("name", "").lower().strip()
            )
            if name:
                pkg_map[name] = {
                    "name": pkg.get("name", ""),
                    "version": pkg.get(
                        "versionInfo", "UNKNOWN"
                    ),
                    "supplier": pkg.get(
                        "supplier", "UNKNOWN"
                    ),
                    "spdxId": pkg.get("SPDXID", ""),
                }
        return pkg_map


# ============================================================
# SBOM comparison
# ============================================================

class SbomComparator:
    """Compares two SPDX package sets and produces analysis."""

    def __init__(self, extractor=None):
        self.extractor = extractor or (
            PackageExtractor()
        )

    def compare(self, omnibor_pkgs, binary_pkgs):
        """Compare two package lists and return analysis dict."""
        omnibor_names = (
            self.extractor.extract_names(
                omnibor_pkgs
            )
        )
        binary_names = (
            self.extractor.extract_names(
                binary_pkgs
            )
        )

        omnibor_map = self.extractor.extract_map(
            omnibor_pkgs
        )
        binary_map = self.extractor.extract_map(
            binary_pkgs
        )

        common = omnibor_names & binary_names
        omnibor_only = omnibor_names - binary_names
        binary_only = binary_names - omnibor_names

        version_match = []
        version_mismatch = []
        for name in sorted(common):
            ov = omnibor_map[name]["version"]
            bv = binary_map[name]["version"]
            if ov == bv:
                version_match.append((name, ov))
            else:
                version_mismatch.append(
                    (name, ov, bv)
                )

        return {
            "omnibor_total": len(omnibor_names),
            "binary_total": len(binary_names),
            "common": sorted(common),
            "omnibor_only": sorted(omnibor_only),
            "binary_only": sorted(binary_only),
            "version_match": version_match,
            "version_mismatch": version_mismatch,
            "omnibor_map": omnibor_map,
            "binary_map": binary_map,
        }


# ============================================================
# Report generation
# ============================================================

class ReportGenerator:
    """Generates markdown comparison reports."""

    @staticmethod
    def generate(
        repo_name, result,
        omnibor_file, binary_file,
    ):
        """Generate a markdown comparison report string."""
        now = datetime.now().isoformat()
        total_union = len(
            set(result["common"])
            | set(result["omnibor_only"])
            | set(result["binary_only"])
        )
        overlap_pct = (
            (
                len(result["common"])
                / total_union * 100
            )
            if total_union > 0 else 0
        )

        report = (
            f"# SBOM Comparison Report"
            f" — {repo_name}\n\n"
            f"**Date:** {now}\n"
            f"**OmniBOR SPDX:** `{omnibor_file}`\n"
            f"**Binary Scan SPDX:** "
            f"`{binary_file}`\n\n"
            "## Summary\n\n"
            "| Metric | Value |\n"
            "|--------|-------|\n"
            f"| OmniBOR packages | "
            f"{result['omnibor_total']} |\n"
            f"| Binary scan packages | "
            f"{result['binary_total']} |\n"
            f"| Common (both detected) | "
            f"{len(result['common'])} |\n"
            f"| OmniBOR only | "
            f"{len(result['omnibor_only'])} |\n"
            f"| Binary scan only | "
            f"{len(result['binary_only'])} |\n"
            f"| Overlap | {overlap_pct:.1f}% |\n"
            f"| Version agreement | "
            f"{len(result['version_match'])} |\n"
            f"| Version mismatch | "
            f"{len(result['version_mismatch'])} "
            "|\n\n"
            "## Common Packages "
            "(detected by both)\n\n"
            "| Package | OmniBOR Version "
            "| Binary Scan Version | Match |\n"
            "|---------|----------------"
            "|--------------------:|-------|\n"
        )

        for name in result["common"]:
            ov = (
                result["omnibor_map"][name]["version"]
            )
            bv = (
                result["binary_map"][name]["version"]
            )
            match = (
                "YES" if ov == bv else "**NO**"
            )
            report += (
                f"| {name} | {ov} "
                f"| {bv} | {match} |\n"
            )

        report += (
            "\n## OmniBOR Only "
            "(not detected by binary scanner)\n\n"
            "These components were identified "
            "during build interception but not\n"
            "found by the binary scanner. "
            "Possible reasons:\n"
            "- Source-only headers or "
            "build-time dependencies\n"
            "- Components compiled into the "
            "binary without distinct signatures\n"
            "- Intermediate build artifacts\n\n"
        )
        for name in result["omnibor_only"]:
            pkg = result["omnibor_map"][name]
            report += (
                f"- **{pkg['name']}** "
                f"({pkg['version']})\n"
            )

        report += (
            "\n## Binary Scan Only "
            "(not detected by OmniBOR)\n\n"
            "These components were identified "
            "by binary signature matching but "
            "not\n"
            "tracked by build interception. "
            "Possible reasons:\n"
            "- Pre-compiled commercial SDKs "
            "or vendor binaries\n"
            "- Statically linked libraries "
            "from system packages\n"
            "- Components not compiled from "
            "source in this build\n\n"
        )
        for name in result["binary_only"]:
            pkg = result["binary_map"][name]
            report += (
                f"- **{pkg['name']}** "
                f"({pkg['version']})\n"
            )

        if result["version_mismatch"]:
            report += (
                "\n## Version Mismatches\n\n"
                "| Package | OmniBOR "
                "| Binary Scan |\n"
                "|---------|---------|"
                "-------------|\n"
            )
            for name, ov, bv in (
                result["version_mismatch"]
            ):
                report += (
                    f"| {name} | {ov} | {bv} |\n"
                )

        report += (
            "\n## Analysis Notes\n\n"
            "- **OmniBOR strengths:** Tracks every "
            "source file through compilation;\n"
            "  captures undeclared and transitive "
            "build dependencies\n"
            "- **Binary scan strengths:** Detects "
            "pre-compiled commercial components\n"
            "  and statically linked code not "
            "visible to build interception\n"
            "- **Combined coverage** provides the "
            "most complete SBOM\n\n"
            "---\n"
            "*Generated by omnibor-analysis "
            f"compare.py on {now}*\n"
        )
        return report


# ============================================================
# Facade: ComparisonPipeline
# ============================================================

class ComparisonPipeline:
    """Orchestrates the full SBOM comparison workflow.

    Composes SpdxLoader, SbomComparator, and
    ReportGenerator.
    """

    def __init__(
        self,
        loader=None,
        comparator=None,
        reporter=None,
    ):
        self.loader = loader or SpdxLoader()
        self.comparator = comparator or (
            SbomComparator()
        )
        self.reporter = reporter or (
            ReportGenerator()
        )


# ============================================================
# CLI entry point
# ============================================================

def main():
    parser = argparse.ArgumentParser(
        description=(
            "Compare OmniBOR vs binary scan SBOMs"
        )
    )
    parser.add_argument(
        "--repo", required=True,
        help="Repository name from config.yaml",
    )
    parser.add_argument(
        "--omnibor-file",
        help="Path to OmniBOR SPDX JSON file",
    )
    parser.add_argument(
        "--binary-file",
        help="Path to binary scan SPDX JSON file",
    )
    args = parser.parse_args()

    config = load_config()
    paths_cfg = config["paths"]
    pipeline = ComparisonPipeline()

    # Find SPDX files
    omnibor_file = (
        args.omnibor_file
        or pipeline.loader.find_latest(
            Path(paths_cfg["output_dir"])
            / "spdx" / args.repo,
            f"{args.repo}_omnibor_*.spdx.json",
        )
    )
    binary_file = (
        args.binary_file
        or pipeline.loader.find_latest(
            Path(paths_cfg["output_dir"])
            / "binary-scan" / args.repo,
            "*.spdx.json",
        )
    )

    if not omnibor_file:
        print(
            "[ERROR] No OmniBOR SPDX file found. "
            "Run analyze.py first or "
            "specify --omnibor-file"
        )
        sys.exit(1)

    if not binary_file:
        print(
            "[ERROR] No binary scan SPDX file "
            "found. Place it in "
            "output/binary-scan/<repo>/ "
            "or specify --binary-file"
        )
        sys.exit(1)

    print(f"OmniBOR SPDX: {omnibor_file}")
    print(f"Binary scan SPDX: {binary_file}")

    # Load and compare
    _, omnibor_pkgs = pipeline.loader.load(
        omnibor_file
    )
    _, binary_pkgs = pipeline.loader.load(
        binary_file
    )

    result = pipeline.comparator.compare(
        omnibor_pkgs, binary_pkgs
    )

    # Generate report
    report = pipeline.reporter.generate(
        args.repo, result,
        omnibor_file, binary_file,
    )

    # Write to docs
    docs_dir = (
        Path(paths_cfg["docs_dir"]) / args.repo
    )
    docs_dir.mkdir(parents=True, exist_ok=True)
    ts = timestamp()
    report_path = (
        docs_dir / f"{ts}_comparison.md"
    )
    with open(
        report_path, "w", encoding="utf-8"
    ) as f:
        f.write(report)

    print(
        f"\n[OK] Comparison report: {report_path}"
    )
    print(
        f"     Common: {len(result['common'])}"
    )
    print(
        "     OmniBOR only: "
        f"{len(result['omnibor_only'])}"
    )
    print(
        "     Binary only: "
        f"{len(result['binary_only'])}"
    )
    print(
        "     Version mismatches: "
        f"{len(result['version_mismatch'])}"
    )


if __name__ == "__main__":
    main()
